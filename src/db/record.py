from src.db.database import change, fetchcolumn, fetchone
from typing import Any, List, Self, TypeVar
from types import NoneType, UnionType
from datetime import datetime
from inspect import get_annotations

Object = TypeVar('Object', bound=object)


class Record:
    '''
    The base class for database records.
    This adds the methods: all, find, load, save, insert, delete.

    You must add a 'table' property to define the database table in which the records are stored.
    You may add an 'ignore_fields' property to define properties that are not stored in the database.
    Neither of these properties should be type annotated so they do not form part of the __init__
    function generated by the @dataclass decorator.
    '''

    @classmethod
    def get_id_column(cls) -> str:
        '''
        Get the name of the column that stores the primary key.

        This will read the `id_column` property if it exists, else it will default to "id".
        '''

        return getattr(cls, 'id_column', 'id')

    def get_id(self) -> str:
        '''
        Get the value of the primary key for this record.
        '''

        return getattr(self, self.get_id_column())

    async def delete(self) -> None:
        '''
        Delete the current database record.
        '''

        await change(f'DELETE FROM {self.table} WHERE {self.get_id_column()} = :id', {'id': self.get_id()})

    @classmethod
    def get_ignore_properties(cls) -> List[str]:
        '''
        Get a list of the names or properties that should not be serialized.
        '''

        return getattr(cls, 'ignore_properties', []) + ['table', 'ignore_properties', 'id_column']

    @classmethod
    def serialize(cls, row: dict) -> dict:
        '''
        Cast data to strings to be stored in the database.
        '''

        data = {}
        annotations = get_annotations(cls)
        ignore_properties = cls.get_ignore_properties()

        for key, value in {k: v for k, v in row.items() if k not in ignore_properties}.items():
            typename = annotations[key]

            # If the type is a union with None, get the non-None type.
            if isinstance(typename, UnionType):
                typename = [t for t in typename.__args__ if t != NoneType][0]

            if value is not None:
                if typename == str or typename == int or typename == datetime:
                    value = str(value)
                elif typename == bool:
                    value = 1 if value else 0
                elif typename == List[int] or typename == List[str]:
                    value = '' if len(value) == 0 else '|'.join(str(val) for val in value)
                else:
                    raise RuntimeError('Unknown data type: ' + str(typename))

            data[key] = value

        return data

    @classmethod
    def deserialize(cls, row: dict) -> dict:
        '''
        Cast data retrieved from the database.
        '''

        data = {}
        annotations = get_annotations(cls)

        for key, value in row.items():
            if key not in annotations:
                raise KeyError(f'Database column {key} not found in class {cls.__name__}')

            typename = annotations[key]

            # If the type is a union with None, get the non-None type.
            if isinstance(typename, UnionType):
                typename = [t for t in typename.__args__ if t != NoneType][0]

            if value is not None:
                if typename == str:
                    pass
                elif typename == int:
                    value = int(value)
                elif typename == datetime:
                    value = datetime.fromisoformat(value)
                elif typename == bool:
                    value = bool(value)
                elif typename == List[int]:
                    value = [] if value == '' else [int(val) for val in value.split('|')]
                elif typename == List[str]:
                    value = [] if value == '' else [val for val in value.split('|')]
                else:
                    raise RuntimeError('Unknown data type: ' + str(typename))

            data[key] = value

        return data

    @classmethod
    async def find(cls, id: Any = None, **kwargs) -> Self | None:
        '''
        Find a database record by the given column name and value.

        Note that the column name is used directly in the SQL and so must not contain user input.

        Examples:

        await Record.find(123)
        await Record.find(discord_id=456)
        '''

        # If an ID is given without a name then use the record's default ID column name.
        if id is not None:
            kwargs = {cls.get_id_column(): id}

        assert len(kwargs) == 1

        column = next(iter(kwargs))
        value = kwargs[column]

        # Fetch the row from the database.
        row = await fetchone(f'SELECT * FROM {cls.table} WHERE {column} = :value COLLATE NOCASE', {'value': value})

        # Return None if the record was not found in the database.
        if row is None:
            return None

        # Values from the datbase come back as strings, so deserialize them to the correct types.
        row = cls.deserialize(row)

        return cls(**row)

    @classmethod
    async def load(cls, id: Any = None, **kwargs) -> Self:
        '''
        Load a single database record.

        Specify a single keyword argument that consists of the column name and value to find.

        Raises an Exception if the record is not found.
        '''

        if id is not None:
            kwargs = {cls.get_id_column(): id}

        result = await cls.find(**kwargs)

        if result is None:
            column = next(iter(kwargs))
            value = kwargs[column]

            raise Exception(f'Failed to find record in {cls.table} where {column} = {value}')

        return result

    @classmethod
    async def all(cls) -> List[Self]:
        '''
        Fetch all records.

        Records are loaded individually in case the class is overriding the load or find method.
        '''

        id_column = cls.get_id_column()
        ids = await fetchcolumn(f'SELECT {id_column} FROM {cls.table} ORDER BY {id_column}')
        records = []

        for id in ids:
            records.append(await cls.load(id))

        return records

    def build_sets(self) -> None:
        '''
        Build a string of "column = :column" for UPDATE statements.
        '''

        columns = vars(self).keys()
        ignore_properties = self.get_ignore_properties()

        # Build a string of "col_1 = :col_1, col_2 = :col2" etc.
        return ', '.join([f'{col} = :{col}' for col in columns if col not in ignore_properties])

    def build_insert_values(self) -> None:
        '''
        Build a string of "(column, ...) VALUES (:column, ...)" for INSERT statements.
        '''

        columns = vars(self).keys()
        ignore_properties = self.get_ignore_properties()

        column_names = ', '.join([col for col in columns if col not in ignore_properties])
        variable_names = ', '.join([':' + col for col in columns if col not in ignore_properties])

        return f'({column_names}) VALUES ({variable_names})'

    async def insert(self) -> None:
        '''
        Insert a new record.
        '''

        insert_values = self.build_insert_values()

        await change(f'INSERT INTO {self.table} {insert_values}', self.serialize(vars(self)))

    async def save(self) -> None:
        '''
        Update an existing record.
        '''

        sets = self.build_sets()
        id = self.get_id_column()

        await change(f'UPDATE {self.table} SET {sets} WHERE {id} = :{id}', self.serialize(vars(self)))
